library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.CPU_Package.all;


ENTITY Controller IS
	PORT(
		adr : OUT address_bus; -- unsigned
		data : IN program_word; -- unsigned
		w_RWM : OUT std_logic;  -- read on high
		RWM_en : OUT std_logic;  -- active low
		ROM_en : OUT std_logic;  -- active low
		clk : IN std_logic;
		reset : IN std_logic;  -- active high
		rw_reg  : OUT std_logic;  -- read on high
		sel_op_1 : OUT unsigned (1 downto 0);
		sel_op_0 : OUT unsigned (1 downto 0);
		sel_in : OUT unsigned (1 downto 0);
		sel_mux : OUT unsigned (1 downto 0);
		alu_op : OUT unsigned (2 downto 0);
		alu_en : OUT std_logic; -- active high
		z_flag : IN std_logic;  -- active high
		n_flag : IN std_logic;  -- active high
		o_flag : IN std_logic; -- active high
		out_en : OUT std_logic; -- active high
		data_imm : OUT data_word -- signed
	); 
END ENTITY Controller; 



architecture Behaviour of Controller is
--type state_type is (Controller_reset, Fetch_instruction, Load_instruction, Decode_instruction,
--							Write_result, Load_data, Store_data, Load_immediate);

-- s0 - Controller_reset,
-- s1 - Fetch_instruction, 
-- s2 - Load_instruction, 
-- s3 - Decode_instruction,
-- s4 - Write_result, 
-- s5 - Load_data, 
-- s6 - Store_data, 
-- s7 - Load_immediate

type state_type is (s0, s1, s2, s3, s4, s5, s6, s7);							
signal next_state, current_state : state_type;

signal PC : address_bus;
signal IR : instruction_bus;

alias instruction : std_logic_vector(3 downto 0) is IR(9 downto 6);
alias R1 : std_logic_vector(1 downto 0) is IR(5 downto 4);
alias R2 : std_logic_vector(1 downto 0) is IR(3 downto 2);
alias R3 : std_logic_vector(1 downto 0) is IR(1 downto 0);
alias mem : std_logic_vector(3 downto 0) is IR(3 downto 0);
alias instruction_alu : unsigned(2 downto 0) is IR(8 downto 6);

begin
	
	process(clk, reset)
	begin
		case current_state is
			when s0 => -- controller_reset
				PC <= (others => '0');
				next_state <= s1;
				
			when s1 => -- fetch_instruction
				adr <= PC;
				rw_reg <= '1';
				next_state <= s3;
				
			when s2 => -- load_instruction
				IR <= data;
				next_state <= s4;
				
			when s3 => -- decode_instruction
				-- WHAAAAAAT IS SUPPOSED TO HAPPEN HERE????????????? I DONT UNDERSTAND
				case instruction is
					
					when "0000" | "0001" | "0010" | "0011" | "0100" => -- ADD, SUB, AND, OR, XOR
						alu_op <= instruction_alu;
						alu_en <= '1';
						sel_op_1 <= R1;
						sel_op_0 <= R2;
						sel_in <= R3;
						next_state <= s4; -- next_state <= write_result
							
					when "0101" | "0110"
						alu_op <= instruction_alu;
						alu_en <= '1';
						sel_op_1 <= R1;
						sel_in <= R3; 
						next_state <= s4; -- next_state <= write_result
						
					when "1001" => -- STR 
						
					when "1011" => -- NOP
						PC <= PC + 1;
						
					when "1100" => -- BRZ mem
						if(z_flag = '1') then 
							PC = mem;
						else
							PC <= PC + 1;
						end if;
						
					when "1101" => -- BRN mem
						if(n_flag = '1') then
							PC <= mem;
						else
							PC <= PC + 1;
						end if;
						
					when "1110" => -- BRO mem
						if(o_flag = '1') then 
							PC = mem;
						else
							PC <= PC + 1;
						end if;
						
					when "1111" => -- BRA
						PC <= mem;
						
				end case;
		
		
			when s4 => --write_result
				rw_reg <= '0';
				sel_mux <= "00";
				next_state <= s1;
				alu_en <= '0';
				PC <= PC + 1;
				
		end case;
	end process;
end architecture;








